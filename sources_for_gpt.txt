# Sources export for GPT
# generated_at: 2025-11-26T02:00:52
# roots: ./app, ./infra
# patterns: *.py, *.yaml, *.yml, *.sql, Makefile, *.txt
# excluded_dirs: .cache, .git, .hg, .idea, .mypy_cache, .svn, .terraform, .venv, .vscode, __pycache__, bazel-bin, bazel-out, bazel-testlogs, build, dist, env, nao-gerar, node_modules, out, target, vendor, venv


===== FILE: app/__init__.py =====
# size: 0 bytes
```python

```

===== FILE: app/db.py =====
# size: 646 bytes
```python
import os
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, DeclarativeBase
from dotenv import load_dotenv

BASE_DIR = os.path.dirname(os.path.dirname(__file__))
load_dotenv(dotenv_path=os.path.join(BASE_DIR, ".env"))

DATABASE_URL = os.getenv(
    "DATABASE_URL",
    "postgresql://postgres:surfamily@localhost:5433/planejadin?sslmode=disable",
)

engine = create_engine(DATABASE_URL, pool_pre_ping=True)
SessionLocal = sessionmaker(bind=engine, autocommit=False, autoflush=False)

class Base(DeclarativeBase):
    pass

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

```

===== FILE: app/deps.py =====
# size: 0 bytes
```python

```

===== FILE: app/main.py =====
# size: 579 bytes
```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from .routers import health, categories, transactions, reports, users, dicas

app = FastAPI(title="PlanejaDin API", version="0.1.0")


app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],      
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(health.router)
app.include_router(categories.router)
app.include_router(transactions.router)
app.include_router(reports.router)
app.include_router(users.router)
app.include_router(dicas.router)

```

===== FILE: app/models.py =====
# size: 3057 bytes
```python
import uuid
from datetime import datetime, date
from sqlalchemy import (
    Column, String, DateTime, Date, Numeric,
    Enum, ForeignKey, CheckConstraint
)
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship, Mapped, mapped_column
from .db import Base
import enum

class TransactionType(str, enum.Enum):
    INCOME = "INCOME"
    EXPENSE = "EXPENSE"

class User(Base):
    __tablename__ = "users"
    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str] = mapped_column(String, nullable=False)
    email: Mapped[str] = mapped_column(String, nullable=False)      # único por índice funcional LOWER(email)
    password_hash: Mapped[str] = mapped_column(String, nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True))
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True))

    categories: Mapped[list["Category"]] = relationship(back_populates="user", cascade="all, delete")
    transactions: Mapped[list["Transaction"]] = relationship(back_populates="user", cascade="all, delete")

class Category(Base):
    __tablename__ = "categories"
    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    name: Mapped[str] = mapped_column(String, nullable=False)
    icon: Mapped[str | None] = mapped_column(String, nullable=True)
    color: Mapped[str | None] = mapped_column(String, nullable=True)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True))
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True))

    user: Mapped["User"] = relationship(back_populates="categories")
    transactions: Mapped[list["Transaction"]] = relationship(back_populates="category")

class Transaction(Base):
    __tablename__ = "transactions"
    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    category_id: Mapped[uuid.UUID | None] = mapped_column(UUID(as_uuid=True), ForeignKey("categories.id", ondelete="SET NULL"))
    type: Mapped[TransactionType] = mapped_column(Enum(TransactionType, name="transaction_type"), nullable=False)
    amount: Mapped[float] = mapped_column(Numeric(14,2), nullable=False)
    date: Mapped[date] = mapped_column(Date, nullable=False)
    description: Mapped[str | None] = mapped_column(String)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True))
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True))

    __table_args__ = (
        CheckConstraint("amount > 0", name="ck_transactions_amount_gt_zero"),
    )

    user: Mapped["User"] = relationship(back_populates="transactions")
    category: Mapped["Category"] = relationship(back_populates="transactions")

```

===== FILE: app/routers/__init__.py =====
# size: 0 bytes
```python

```

===== FILE: app/routers/categories.py =====
# size: 1284 bytes
```python
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from uuid import UUID
from datetime import datetime, timezone
from ..db import get_db
from .. import models, schemas

router = APIRouter(prefix="/categories", tags=["categories"])

@router.get("", response_model=list[schemas.CategoryOut])
def list_categories(user_id: UUID = Query(...), db: Session = Depends(get_db)):
    return db.query(models.Category).filter(models.Category.user_id == user_id).order_by(models.Category.name).all()

@router.post("", response_model=schemas.CategoryOut, status_code=201)
def create_category(
    user_id: UUID = Query(...),
    payload: schemas.CategoryCreate = ...,
    db: Session = Depends(get_db)
):
    # regra de unicidade por usuário (name)
    exists = db.query(models.Category).filter(
        models.Category.user_id == user_id,
        models.Category.name.ilike(payload.name)
    ).first()
    if exists:
        raise HTTPException(status_code=409, detail="Category already exists")

    now = datetime.now(timezone.utc)
    cat = models.Category(
        user_id=user_id, name=payload.name, icon=payload.icon, color=payload.color,
        created_at=now, updated_at=now
    )
    db.add(cat); db.commit(); db.refresh(cat)
    return cat

```

===== FILE: app/routers/dicas.py =====
# size: 1310 bytes
```python
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel

router = APIRouter(prefix="/dicas", tags=["dicas"])


class DicaIn(BaseModel):
    mensagem: str


class DicaOut(BaseModel):
    resposta: str


def _montar_resposta(mensagem: str) -> str:
    """
    Gera uma resposta simples a partir da mensagem.
    Mantém tudo local (sem chamadas externas) para servir de mock.
    """
    texto = mensagem.lower()

    if not texto.strip():
        raise HTTPException(status_code=400, detail="mensagem não pode ser vazia")

    if "meta" in texto or "objetivo" in texto:
        return "Vou acompanhar suas metas: defina um valor mensal, crie alertas e revise toda semana."

    if "econom" in texto or "poupar" in texto:
        return "Dica rápida: separe 10% assim que receber, negocie tarifas e revise assinaturas mensais."

    if "dívida" in texto or "divida" in texto or "cartão" in texto:
        return "Priorize dívidas com juros maiores, pague acima do mínimo e considere portabilidade ou renegociação."

    return "Anotado! Posso sugerir metas, cortes de gastos e melhores datas de vencimento para ajudar."


@router.post("", response_model=DicaOut)
def gerar_dica(payload: DicaIn):
    resposta = _montar_resposta(payload.mensagem)
    return DicaOut(resposta=resposta)

```

===== FILE: app/routers/health.py =====
# size: 134 bytes
```python
from fastapi import APIRouter
router = APIRouter(tags=["health"])

@router.get("/healthz")
def healthz():
    return {"status": "ok"}

```

===== FILE: app/routers/reports.py =====
# size: 1190 bytes
```python
from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session
from sqlalchemy import func, case, extract
from uuid import UUID
from ..db import get_db
from .. import models, schemas

router = APIRouter(prefix="/reports", tags=["reports"])

@router.get("/monthly", response_model=schemas.MonthlyReportOut)
def monthly(
    user_id: UUID = Query(...),
    year: int = Query(..., ge=1900, le=3000),
    month: int = Query(..., ge=1, le=12),
    db: Session = Depends(get_db)
):
    # soma condicional por mês
    total_income, total_expense = db.query(
        func.coalesce(func.sum(case((models.Transaction.type == models.TransactionType.INCOME, models.Transaction.amount), else_=0)), 0),
        func.coalesce(func.sum(case((models.Transaction.type == models.TransactionType.EXPENSE, models.Transaction.amount), else_=0)), 0),
    ).filter(
        models.Transaction.user_id == user_id,
        extract('year', models.Transaction.date) == year,
        extract('month', models.Transaction.date) == month
    ).one()

    return schemas.MonthlyReportOut(
        year=year, month=month,
        total_income=float(total_income), total_expense=float(total_expense)
    )

```

===== FILE: app/routers/transactions.py =====
# size: 2828 bytes
```python
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from uuid import UUID
from datetime import datetime, timezone, date as dt_date
from ..db import get_db
from .. import models, schemas

router = APIRouter(prefix="/transactions", tags=["transactions"])

@router.get("", response_model=list[schemas.TransactionOut])
def list_transactions(
    user_id: UUID = Query(...),
    date_from: dt_date = Query(...),
    date_to: dt_date = Query(...),
    category_id: UUID | None = Query(None),
    type: models.TransactionType | None = Query(None),
    db: Session = Depends(get_db)
):
    q = db.query(models.Transaction).filter(
        models.Transaction.user_id == user_id,
        models.Transaction.date.between(date_from, date_to)
    )
    if category_id: q = q.filter(models.Transaction.category_id == category_id)
    if type: q = q.filter(models.Transaction.type == type)
    return q.order_by(models.Transaction.date.desc(), models.Transaction.created_at.desc()).all()

@router.post("", response_model=schemas.TransactionOut, status_code=201)
def create_transaction(
    user_id: UUID = Query(...),
    payload: schemas.TransactionCreate = ...,
    db: Session = Depends(get_db)
):
    # se categoria informada, precisa pertencer ao mesmo user
    if payload.category_id:
        cat = db.query(models.Category).filter(
            models.Category.id == payload.category_id,
            models.Category.user_id == user_id
        ).first()
        if not cat:
            raise HTTPException(status_code=400, detail="category_id does not belong to user")

    now = datetime.now(timezone.utc)
    tx = models.Transaction(
        user_id=user_id,
        category_id=payload.category_id,
        type=payload.type,
        amount=payload.amount,
        date=payload.date,
        description=payload.description,
        created_at=now,
        updated_at=now
    )
    db.add(tx); db.commit(); db.refresh(tx)
    return tx

@router.get("/{tx_id}", response_model=schemas.TransactionOut)
def get_transaction(
    tx_id: UUID,
    user_id: UUID = Query(...),
    db: Session = Depends(get_db),
):
    tx = db.query(models.Transaction).filter(
        models.Transaction.id == tx_id,
        models.Transaction.user_id == user_id,
    ).first()
    if not tx:
        raise HTTPException(status_code=404, detail="Transaction not found")
    return tx


@router.delete("/{tx_id}", status_code=204)
def delete_transaction(
    tx_id: UUID,
    user_id: UUID = Query(...),
    db: Session = Depends(get_db),
):
    tx = db.query(models.Transaction).filter(
        models.Transaction.id == tx_id,
        models.Transaction.user_id == user_id,
    ).first()
    if not tx:
        raise HTTPException(status_code=404, detail="Transaction not found")
    db.delete(tx)
    db.commit()

```

===== FILE: app/routers/users.py =====
# size: 1524 bytes
```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from datetime import datetime, timezone
from pydantic import BaseModel, EmailStr
from uuid import UUID
from ..db import get_db
from .. import models

router = APIRouter(prefix="/users", tags=["users"])

class RegisterIn(BaseModel):
    name: str
    email: EmailStr
    password: str

class LoginIn(BaseModel):
    email: EmailStr
    password: str

class UserOut(BaseModel):
    id: UUID
    name: str
    email: EmailStr
    class Config: from_attributes = True

@router.post("/register", response_model=UserOut, status_code=201)
def register(payload: RegisterIn, db: Session = Depends(get_db)):
    exists = db.query(models.User).filter(models.User.email == payload.email).first()
    if exists:
        raise HTTPException(status_code=409, detail="Email already registered")

    now = datetime.now(timezone.utc)
    user = models.User(
        name=payload.name,
        email=payload.email,
        password_hash=payload.password,  # depois vcs colocam hash de verdade
        created_at=now,
        updated_at=now,
    )
    db.add(user); db.commit(); db.refresh(user)
    return user

@router.post("/login", response_model=UserOut)
def login(payload: LoginIn, db: Session = Depends(get_db)):
    user = db.query(models.User).filter(models.User.email == payload.email).first()
    if not user or user.password_hash != payload.password:
        raise HTTPException(status_code=401, detail="Invalid credentials")
    return user

```

===== FILE: app/schemas.py =====
# size: 1313 bytes
```python
from pydantic import BaseModel, EmailStr, Field
from typing import Optional
from datetime import date, datetime
from uuid import UUID
from .models import TransactionType

# ---- Users ----
class UserOut(BaseModel):
    id: UUID
    name: str
    email: EmailStr
    created_at: datetime
    updated_at: datetime
    class Config: from_attributes = True

# ---- Categories ----
class CategoryCreate(BaseModel):
    name: str = Field(min_length=1)
    icon: Optional[str] = None
    color: Optional[str] = None

class CategoryOut(BaseModel):
    id: UUID
    name: str
    icon: Optional[str]
    color: Optional[str]
    created_at: datetime
    updated_at: datetime
    class Config: from_attributes = True

# ---- Transactions ----
class TransactionCreate(BaseModel):
    category_id: Optional[UUID] = None
    type: TransactionType
    amount: float = Field(gt=0)
    date: date
    description: Optional[str] = None

class TransactionOut(BaseModel):
    id: UUID
    category_id: Optional[UUID]
    type: TransactionType
    amount: float
    date: date
    description: Optional[str]
    created_at: datetime
    updated_at: datetime
    class Config: from_attributes = True

# ---- Reports ----
class MonthlyReportOut(BaseModel):
    year: int
    month: int
    total_income: float
    total_expense: float

```

===== FILE: infra/db/init/01_schema.sql =====
# size: 2568 bytes
```
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type') THEN
    CREATE TYPE transaction_type AS ENUM ('INCOME', 'EXPENSE');
  END IF;
END$$;

CREATE TABLE IF NOT EXISTS users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  email TEXT NOT NULL,
  password_hash TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE UNIQUE INDEX IF NOT EXISTS uq_users_email_lower ON users (LOWER(email));

CREATE TABLE IF NOT EXISTS categories (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  icon TEXT,
  color TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT uq_categories_user_name UNIQUE (user_id, name)
);
CREATE INDEX IF NOT EXISTS idx_categories_user ON categories(user_id);

CREATE TABLE IF NOT EXISTS transactions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  category_id UUID NULL REFERENCES categories(id) ON DELETE SET NULL,
  type transaction_type NOT NULL,
  amount NUMERIC(14,2) NOT NULL CHECK (amount > 0),
  date DATE NOT NULL,
  description TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_tx_user_date      ON transactions(user_id, date);
CREATE INDEX IF NOT EXISTS idx_tx_user_cat_date  ON transactions(user_id, category_id, date);
CREATE INDEX IF NOT EXISTS idx_tx_user_type_date ON transactions(user_id, type, date);

CREATE OR REPLACE FUNCTION set_updated_at() RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_users_updated_at') THEN
    CREATE TRIGGER trg_users_updated_at
      BEFORE UPDATE ON users
      FOR EACH ROW EXECUTE FUNCTION set_updated_at();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_categories_updated_at') THEN
    CREATE TRIGGER trg_categories_updated_at
      BEFORE UPDATE ON categories
      FOR EACH ROW EXECUTE FUNCTION set_updated_at();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_transactions_updated_at') THEN
    CREATE TRIGGER trg_transactions_updated_at
      BEFORE UPDATE ON transactions
      FOR EACH ROW EXECUTE FUNCTION set_updated_at();
  END IF;
END$$;

```

# total_files: 14
